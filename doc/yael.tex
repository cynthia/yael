\documentclass[a4paper,11pt,notitlepage,final,twoside]{report}

% Options possibles : 10pt, 11pt, 12pt (taille de la fonte)
%                     oneside, twoside (recto simple, recto-verso)
%                     draft, final 
%                     titlepage, notitlepage 

\usepackage[utf8]{inputenc}   % LaTeX, comprends les accents !
\usepackage[hmargin=2.5cm,vmargin=2.5cm]{geometry}         % Definir les marges
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{url}

% \pagestyle{headings}        % Pour mettre des entetes avec les titres
                              % des sections en haut de page

\newcommand{\yael}{\textsc{Yael}\xspace}
\newcommand{\yroot}{\texttt{YAELROOT}\xspace}
\newcommand{\tc}[1]{\texttt{#1}}
\newcommand{\code}[1]{\smallskip 

\texttt{#1} 
 \medskip

}

\setlength{\parindent}{0pt}

\title{~\vspace{9cm} \\ \yael: Getting started} 
\author{Matthijs Douze \and Herv\'e J\'egou}
\date{April 20\textsuperscript{th}, 2010} 


\begin{document}

\maketitle
\thispagestyle{empty}

\vfill

\includegraphics[width=3cm]{./figs/logoinria}


\newpage

\chapter*{Licence}

\thispagestyle{empty}

Copyright @ INRIA 2010. \\
Authors: Matthijs Douze \& Herv\'e J\'egou \\
Contact: matthijs.douze@inria.fr  herve.jegou@inria.fr \\
\medskip

This software is a computer program whose purpose is to provide 
efficient tools for basic yet computationally demanding tasks, 
such as find k-nearest neighbors using exhaustive search 
and kmeans clustering. 
\medskip

This software is governed by the CeCILL license under French law and
abiding by the rules of distribution of free software.  You can  use, 
modify and/ or redistribute the software under the terms of the CeCILL
license as circulated by CEA, CNRS and INRIA at the following URL
\url{http://www.cecill.info}, and provided within the \yael library 
in the file LICENSE. 
\medskip

As a counterpart to the access to the source code and  rights to copy,
modify and redistribute granted by the license, users are provided only
with a limited warranty  and the software's author,  the holder of the
economic rights,  and the successive licensors  have only  limited
liability. 
\medskip

In this respect, the user's attention is drawn to the risks associated
with loading,  using,  modifying and/or developing or reproducing the
software by the user in light of its specific status of free software,
that may mean  that it is complicated to manipulate,  and  that  also
therefore means  that it is reserved for developers  and  experienced
professionals having in-depth computer knowledge. Users are therefore
encouraged to load and test the software's suitability as regards their
requirements in conditions enabling the security of their systems and/or 
data to be ensured and,  more generally, to use and operate it in the 
same conditions as regards security. 
\medskip

The fact that you are presently reading this means that you have had
knowledge of the CeCILL license and that you accept its terms.


\tableofcontents            % Table des matieres


\chapter{What is this?}

This is a tutorial for first steps with \yael. Most of the remarks and details here will be just but useless for skilled programmers, as the structure of the library should be clear enough. The documentation related to Python should however interest any programmer wanting to use this interface. 
\medskip

\yael is a library for performing efficient basic operations, 
in particular kmeans and exhaustive nearest neighbor search function.
It offers three interfaces: 
\begin{itemize}
\item C, 
\item Python, 
\item Matlab.
\end{itemize}

The library has been tested under different architectures, in particular
\begin{itemize}
\item Linux 32 bits: Fedora Core 11
\item Linux 64 bits: Fedora Core 10, Fedora Core 11, Ubuntu Karmic, Debian 4.1.2-25
\item Mac OS X 64 bits. 
\end{itemize}
The library has not been packaged nor tested for Microsoft Windows. 

The C API is object-oriented in spirit whenever applicable, with constructors and destructors for each structure. All functions are re-entrant, but unless otherwise specified, they are not multi-threaded. Threading is assumed to occur at a higher level. 

\chapter{Getting Started}
\label{cha:gettingstarted}

\section{\yael: getting SVN version and content}

The latest version of yael can be retrieved from the SVN as follows:

\code{svn checkout svn+ssh://mygforgelogin@scm.gforge.inria.fr/svn/yael/trunk yael}
*** add anonymous access when available ***
\medskip


This performs the installation of the regular \yael branch of the project into the directory \texttt{yael}. 
This installation directory is referred to as~\yroot in the following. 
The library is organized as follows: 
\medskip

\begin{tabular}{ll}
\tc{\yroot/}         & root directory \\
\tc{\yroot/LICENCE}  & licensing information \\
\tc{\yroot/Makefile} & generic Makefile \\
\tc{\yroot/makefile.inc}  & configuration file generated by \tc{configure.sh}\\
\tc{\yroot/configure.sh}  & Configuration program with basic auto-detection procedures.  \\
\tc{\yroot/README}   & subset of this getting started manual \\
~\\
\tc{\yroot/doc/}     & documentation: getting started and reference manuals \\
\tc{\yroot/matlab/}  & matlab interface \\
\tc{\yroot/progs/}   & executable programs: front-end and utilities \\
\tc{\yroot/test/}    & sample test programs for various functions \\
\tc{\yroot/yael/}    & core yael directory  \\
\end{tabular}


\section{Prerequisites}

The library requires the following software/libraries to be installed. 
Some of them are related to the non-core interfaces (python and matlab) 
and are not strictly mandatory. 

\begin{description}
\item [Blas and Lapack.] Any implementation should work as it is
wrapped with the Fortran calling conventions. 
It might be required to adjust the location of these libraries in 
the \tc{makefile.inc} file generated by the \tc{configure.sh} script. 
The \tc{LD\_LIBRARY\_PATH} environment variable may also need to be set accordingly. 

\item [Python-dev.] This package contains the include files of the Python-C API. 
Note that having python installed on your machine does not necessarily 
mean that the developpement kit is installed as well. 
If only python is installed, not python-dev, you will get an error 
saying that the file \tc{Python.h} can not be found. 

\item [swig] 
is required to create the python interface. 

\item [Matlab] is required only for the matlab \yael interface. 
It is not compiled by default. 


\item [doxygen] is used to generate the reference manual (HTML) from the source files. 

\item [pdflatex] is used to re-generate this ``getting started'' manual. 
\end{description}


These two last pre-requisites are required by the Python interface 
and are not strictly mandatory. If you are not interested by this 
Python interface and that you don't have python-dev and swig installed, 
you should remove the target \tc{\_yael.so} target in the Makefile of the 
yael core directory. 


\section{Installation procedure}

The source is compiled with hand-written Makefiles. 
All system-dependent options are defined in the toplevel \tc{makefile.inc}. 
\bigskip

{\bf 1\,--} \tc{./configure.sh} in the yael root directory, which generates 
the file \tc{makefile.inc} using basic auto-detection procedures. 
For most configurations, these should be sufficient. However you might need 
to adjust the variables defined in makefile.inc to fit your local configuration. 
\bigskip

{\bf 2\,--} \tc{make}
\bigskip

{\bf 3\,--} Try to compile the programs in progs and test
\medskip

At this point, only the core C and python library are compiled. 
If you need the Matlab interface, you have to compile the mex files:
\bigskip

{\bf 4\,--} \tc{cd matlab ; make}
\smallskip

The mex executable should be in the PATH. 
\bigskip

In order to generate the reference manual and this tutorial, you should go into the 
doc subdirectory and execute the following command line. 
\smallskip

{\bf 5\,--} \tc{cd doc; make}
\bigskip

{\it Remarks:}
\begin{itemize}
\item In order to use the 64 bit mode on MacOS (preferred), 
the flag \tc{-m64} should be set for the configuration, as:
\code{CFLAGS=-m64 LDFLAGS=-m64 ./configure.sh}
\end{itemize}


\chapter{C interface and basic programs}

The C API is object-oriented whenever applicable, with constructors and destructors for each structure. 
\medskip

The include directory should be set to the \yroot directory, so that a yael file is included using the prefix \texttt{yael/}. 
For instance, including the primitive for vectors is performed by
\code{
\#include <yael/vector.h>
}
\medskip

The documentation of the functions and data strcutures is in the header files. It can be extracted and formatted by \texttt{doxygen}, run by invoking \texttt{make} in the \texttt{doc} subdirectory. 
\medskip

The best thing to do to have an operational Makefile and program 
is probably to look at the test files included in the 
\tc{\yroot/test/} subdirectory. 
\bigskip

\section{Multi-threading in \yael}

In order to exploit multi-CPU and multi-core architectures, many functions in \yael execute in multiple threads. They take an additional parameter (\tc{int nt}) that defines the number of threads to use. 

The total number of available CPUs is given by the \tc{count\_cpu()} function. 

\subsection{Multi-threading primitive}

Most multi-threading operations in \yael are implemented via the function 
\begin{verbatim}
void compute_tasks (int n, int nt,
                    void (*task_fun) (void *arg, int tid, int i),
                    void *task_arg);
\end{verbatim}

The function executes \tc{n} tasks on \tc{nthread} threads. For each task, the callback \tc{task\_fun} is called with \tc{task\_arg} as first argument, \tc{i = 0..n-1} set to the task number, and \tc{tid = 0..nt-1} set to the thread number. 

Some operations are also multi-threaded via OpenMP pragmas (when enabled in the \tc{./configure.sh} script).


\subsection{Best practices}

It is often advisable to perform multi-threading at the highest level possible. For example, with two nested loops: 

\begin{verbatim}
for (i = 0 ; i < 1000 ; i++)    
  for (j = 0 ; j < 1000 ; i++) 
    expensive_operation (i, j);
\end{verbatim}

it is more efficient (and often easier) to define a task as one outer loop. This reduces the number of synchronization barriers. 

*** nt=count\_cpu() ***

*** maybe add the simpliest example as possible in the test directory, 
or even in this documentation  *** 

\chapter{Python}

The whole C API is exposed in Python using SWIG, hence the \tc{.swg} files in the subdirectories. This allows to call C functions from Python more or less transparently. 


\section{Loading and using \yael}

Assuming that the \tc{PYTHONPATH} environment variable is set to \yroot, 
importing the \yael interface and creating a new is done as 
\code{from yael import yael  \\
a = yael.fvec\_new\_0(5)
}

In order to shorten the call, one could also import the function 
in the current namespace, as
\code{from yael.yael import * \\
a = fvec\_new\_0(5)
}

However, we do not advice to do so, in order to avoid function name conflicts 
when using other python libraries jointly with \yael. 

\section{Guidelines for the wrapping process}

\begin{itemize}
\item for most of the objects, memory is not managed by Python. They must be free'd explicitly. The main exception is for vectors, which can be expicitely acquired by Python so that they are garbage-collected like a Python object;
\item arrays for simple types are wrapped with IntArray, FloatArray, etc. 

  Usage:

      \tc{a=IntArray(4)} constructs an array of 4 ints, accessible in Python with \tc{a[2]}. 

      \tc{a.cast()} returns an int* usable as a C function argument (most of the time, the cast is automatic, and \tc{a} can be used when a function expects an \tc{int *})
      % if x is a int* in C, ***RV: c'est pas automatiquement fait, ca? ***
      
      \tc{b=IntArray.frompointer(x)} makes the Python \tc{a[i]} valid to access C's \tc{x[i]}.

      \tc{b.plus(2)} returns \tc{x+2} (pointer arithmetic).

      \tc{b=IntArray.acquirepointer(x)} will in addition make \tc{free(x)} when b is deleted. This function therefore ensures that \tc{x} will be collected 
by the python garbage manager. There is no problem in using the same 
variable name: \tc{x=IntArray.acquirepointer(x)}

\item Any function that may last long must be wrapped with the macro \tc{PARALLEL\_FUNCTION} in the SWIG code, or it will block other threads from executing. 

\item output arguments in the C code (marked with \tc{\_out}) are returned as Python tuples. *** say a bit more ***
\end{itemize}


\section{NumPy interface}


\chapter{Matlab}

This chapter is dedicated to the Matlab interface. 
However most of the comments here have their Octave equivalent. 

\section{Content of the matlab interface}

The matlab interface of \yael is quite limited because most 
of the functions are standard in matlab or can be straightforwardly 
implemented. 
The list of functions currently provided is the following
\begin{description}
\item  [yael\_kmeans.] Although there is a kmeans function in matlab, 
that one is not very efficient. Moreover, it is not available in 
the core matlab program, since it requires a specific toolbox. 
\item [yael\_knn] is used to find the $k$ nearest neighbors with respect 
to the Euclidean distance. Although for $k=1$ matlab makes a good job, 
finding $k>1$ neighbors requires to use the \tc{sort} 
function, which is very inefficient when $k$ is small compared to the number 
of vectors. 
\end{description}


\section{Using the \yael interface}

The functions are implemented by Mex-file, 
which requires to compile the matlab interface of \yael 
(not done by default). To do so, just type \tc{make}
in the \tc{\yroot/matlab} directory\footnote{You might 
obtain a warning about the version of mex. We never observed 
any trouble related to that point. }. 
In order for the matlab functions to be found in matlab, 
you should include this subdirectory in the MATLAB path, for 
instance by putting the command 

\code{
export MATLABPATH=\$MATLABPATH:\yroot/matlab
}

in your shell configuration files (e.g., \tc{.bash\_profile} for bash) 
where \yroot should be set to fit your local configuration 
(see Section~\ref{cha:gettingstarted}). 
\bigskip

Similar to Fortran convention, all vectors are assumed stored in column. 
\bigskip

All the functions of the \yael matlab interface use 
single precision vectors, i.e., the matlab 
equivalent of float. This is in contrast to matlab default type, 
where double precision floating numbers are used by default. 
Therefore, one has to cast the input data to single precision 
when calling \yael functions, e.g., as 

\code{
[dis,ids]=yael\_nn(single(v),single(q),10)
}

\chapter{Troubleshooting}

Before reporting any trouble in installing the library, please
ensure that the following points are correctly configured 
Most of the problems should be related to an incorrect configuration 
in~\tc{makefile.inc}. 


\begin{description}
\item [Problems when linking.] The environment variable associated with dynamic library should be set to \tc{\yroot/yael}. 

{~ \hfill 
\begin{tabular}{|lll|}
\hline
Architecture & \yael library name  &  environment variable  \\
\hline
Linux 32/64  & \tc{libyael.so}  & \tc{LD\_LIBRARY\_PATH} \\
MacOS       & \tc{libyael.dylib} & \tc{DYLD\_LIBRARY\_PATH} \\
\hline
\end{tabular} \hfill ~}

\item [Python.] The \tc{PYTHONPATH} environment variable should 
point to \tc{YAELROOT}. 

\end{description}

To check the dependancies for the library, you can use the following commands:
\begin{itemize}
\item Linux: \tc{ldd libyael}
\item MacOS: \tc{otool -L libyael.dylib}
\end{itemize}


\appendix                     % Les annexes

\chapter{File exchange format}               % Annexe A

\yael uses a home-made file format to store integer or floating point vectors. 
Each vector is stored by
\begin{itemize}
\item writing its length $d$ as an integer
\item and writing its $d$ components in binary format. 
\end{itemize}
We only store single-precision floating point number\footnote{For double precision you need to use the standard I/O functions. But do you really need double precision ?}. Therefore the size of storing a vector of integer or a vector of floating point numbers is always \tc{sizeof(int)+4*d}$=4(d+1)$, as both the dimension and the components require 4 bytes each.  
\medskip

By convention we will call a file containing several vectors of the same kind ``fvecfile'' and ``ivecfile''. 
Some particular high-level functions are defined for these files. 
\bigskip

{\it Remarks:} 
\begin{itemize}
\item Since there use no header, several fvecfiles or ivecfiles can be concatenated using regular the \tc{cat} Unix command to produce a file containing the concatenation of the vector. 
\item the front-ends \tc{fvecfile} and \tc{ivecfile} receive a fvecfile (resp., ivecfile) on standard input and produce a text output. Usage:
\code{
cat myfile.fvecs | fvecfile
}
or, equivalently, 
\code{
fvecfile < myfile.fvecs
}
They are provided in the prog directory. 
\end{itemize}


One can see below the set of \yael functions used to read these files:
\begin{tabular}{lll}
C         &*** & \\
          & & \\
matlab    & & \\
python    & & \\
\end{tabular}


Recall that these functions should be used only for files containing vectors of same type and dimension. 
However, thanks to the fact that the dimension is stored for each vector, variable length vectors 
can also be used, but in that case vectors must be accessed one by one. 

% \listoffigures              % Table des figures

% \listoftables               % Liste des tableaux

\end{document}
