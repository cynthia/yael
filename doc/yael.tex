\documentclass[a4paper,11pt,notitlepage,final,twoside]{report}

% Options possibles : 10pt, 11pt, 12pt (taille de la fonte)
%                     oneside, twoside (recto simple, recto-verso)
%                     draft, final 
%                     titlepage, notitlepage 

\usepackage[utf8]{inputenc}   % LaTeX, comprends les accents !
\usepackage[hmargin=2.5cm,vmargin=2.5cm]{geometry}         % Definir les marges
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{url}

% \pagestyle{headings}        % Pour mettre des entetes avec les titres
                              % des sections en haut de page

\newcommand{\yael}{\textsc{Yael}\xspace}
\newcommand{\yroot}{\texttt{YAELROOT}\xspace}
\newcommand{\tc}[1]{\texttt{#1}}
\newcommand{\code}[1]{\smallskip 

\texttt{#1} 
 \medskip

}

\setlength{\parindent}{0pt}

\title{~\vspace{9cm} \\ \yael: Getting started} 
\author{Matthijs Douze \and Herv\'e J\'egou}
\date{October 2010} 


\begin{document}

\maketitle
\thispagestyle{empty}

\vfill

\includegraphics[width=3cm]{./figs/logoinria} \hfill \includegraphics[width=2cm]{./figs/logoyael} 


\newpage

\chapter*{License}

\thispagestyle{empty}

Copyright @ INRIA 2010. \\
Authors: Matthijs Douze \& Herv\'e J\'egou \\
Contact: matthijs.douze@inria.fr  herve.jegou@inria.fr \\
\medskip

This software is a computer program whose purpose is to provide 
efficient tools for basic yet computationally demanding tasks, 
such as find k-nearest neighbors using exhaustive search 
and kmeans clustering. 
\medskip

This software is governed by the CeCILL license under French law and
abiding by the rules of distribution of free software.  You can  use, 
modify and/ or redistribute the software under the terms of the CeCILL
license as circulated by CEA, CNRS and INRIA at the following URL
\url{http://www.cecill.info}, and provided within the \yael library 
in the file LICENSE. 
\medskip

As a counterpart to the access to the source code and  rights to copy,
modify and redistribute granted by the license, users are provided only
with a limited warranty  and the software's author,  the holder of the
economic rights,  and the successive licensors  have only  limited
liability. 
\medskip

In this respect, the user's attention is drawn to the risks associated
with loading,  using,  modifying and/or developing or reproducing the
software by the user in light of its specific status of free software,
that may mean  that it is complicated to manipulate,  and  that  also
therefore means  that it is reserved for developers  and  experienced
professionals having in-depth computer knowledge. Users are therefore
encouraged to load and test the software's suitability as regards their
requirements in conditions enabling the security of their systems and/or 
data to be ensured and,  more generally, to use and operate it in the 
same conditions as regards security. 
\medskip

The fact that you are presently reading this means that you have had
knowledge of the CeCILL license and that you accept its terms.


\tableofcontents            % Table des matieres


\chapter{What is this?}

This is a tutorial for first steps with \yael. Most of the remarks and details here will be just but useless for skilled programmers, as the structure of the library should be clear enough. The documentation related to Python should however interest any programmer wanting to use this interface. 
\medskip

\yael is a library for performing efficient basic operations, 
in particular kmeans and exhaustive nearest neighbor search function.
It offers three interfaces: 
\begin{itemize}
\item C, 
\item Python, 
\item Matlab\footnote{Octave extension is included, but not fully checked at each release.}.
\end{itemize}

The library has been tested under different architectures, in particular
\begin{itemize}
\item Linux 32 bits: Fedora Core 11
\item Linux 64 bits: Fedora Core 10, Fedora Core 11, Ubuntu Karmic, Debian 4.1.2-25
\item Mac OS X. 
\end{itemize}
The library has not been packaged nor tested for Microsoft Windows. 

The C API is object-oriented in spirit whenever applicable, with constructors and destructors for each structure. All functions are re-entrant, but unless otherwise specified, they are not multi-threaded. Threading is assumed to occur at a higher level. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Getting Started}
\label{cha:gettingstarted}

\section{\yael: getting SVN version and content}

Retrieve the last archive file on the gforge INRIA web server. 
Windows users should probably use an older version, as we do not support Windows (existing 
versions are external contributions which are not maintained). 
\medskip

You may be interested in the last in obtaining the latest version of \yael. 
For registered users, it can be retrieved from the SVN as follows:

\code{svn checkout svn+ssh://mygforgelogin@scm.gforge.inria.fr/svn/yael/trunk yael}

This performs the installation of the regular \yael branch of the project into the directory \texttt{yael}. 
This installation directory is referred to as~\yroot in the following. 
There is also an anonymous access, which is provided by using one of the following commands:

\code{svn checkout svn://scm.gforge.inria.fr/svn/yael \\
svn checkout --username anonsvn https://scm.gforge.inria.fr/svn/yael
}

The password for anonymous login is 'anonsvn'. 
\medskip


The library is organized as follows: 
\smallskip

\begin{tabular}{ll}
\tc{\yroot/}         & root directory \\
\tc{\yroot/LICENCE}  & licensing information \\
\tc{\yroot/Makefile} & generic Makefile \\
\tc{\yroot/makefile.inc}  & configuration file generated by \tc{configure.sh}\\
\tc{\yroot/configure.sh}  & Configuration program with basic auto-detection procedures.  \\
\tc{\yroot/README}   & subset of this getting started manual \\
~\\
\tc{\yroot/doc/}     & documentation: getting started and reference manuals \\
\tc{\yroot/matlab/}  & matlab interface \\
\tc{\yroot/progs/}   & executable programs: front-end and utilities \\
\tc{\yroot/test/}    & sample test programs for various functions \\
\tc{\yroot/yael/}    & core yael directory  \\
\end{tabular}


\section{Prerequisites}

The library requires the following software/libraries to be installed. 
Some of them are related to the non-core interfaces (python and matlab) 
and are not strictly mandatory. 

\begin{description}
\item [Blas and Lapack.] Any implementation should work as it is
wrapped with the Fortran calling conventions. 
It might be required to adjust the location of these libraries in 
the \tc{makefile.inc} file generated by the \tc{configure.sh} script. 
The \tc{LD\_LIBRARY\_PATH} environment variable may also need to be set accordingly. 

\item [Python-dev.] This package contains the include files of the Python-C API. 
Note that having python installed on your machine does not necessarily 
mean that the development kit is installed as well. 
If only python is installed, not python-dev, you will get an error 
saying that the file \tc{Python.h} can not be found. 

\item [swig] 
is required to create the python interface. 

\item [Matlab] is required only for the matlab \yael interface. 
It is not compiled by default. 

\item [doxygen] is used to generate the reference manual (HTML) from the source files. 

\item [pdflatex] is used to re-generate this ``getting started'' manual. 
\end{description}


These two last pre-requisites are required by the Python interface 
and are not strictly mandatory. If you are not interested by this 
Python interface and that you don't have python-dev and swig installed, 
you should remove the target \tc{\_yael.so} target in the Makefile of the 
yael core directory. 


\section{Installation procedure}

The source is compiled with hand-written Makefiles. 
All system-dependent options are defined in the toplevel \tc{makefile.inc}. 
\bigskip

{\bf 1\,--} \tc{./configure.sh} in the yael root directory, which generates 
the file \tc{makefile.inc} using basic auto-detection procedures. 
For most configurations, these should be sufficient. However you might need 
to adjust the variables defined in makefile.inc to fit your local configuration. 
\bigskip

{\bf 2\,--} \tc{make}
\bigskip

{\bf 3\,--} Try to compile the programs in progs and test
\medskip

At this point, only the core C and python library are compiled. 
If you need the Matlab interface, you have to compile the mex files:
\bigskip

{\bf 4\,--} \tc{cd matlab ; make}
\smallskip

The mex executable should be in the PATH. 
\bigskip

In order to generate the reference manual and this tutorial, you should go into the 
doc subdirectory and execute the following command line. 
\smallskip

{\bf 5\,--} \tc{cd doc; make}
\bigskip

{\it Remarks:}
\begin{itemize}
\item In order to use the 64 bit mode on MacOS (preferred), 
use the special flag \tc{--mac64}: 
\code{./configure.sh --mac64}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{C interface and basic programs}

The C API is object-oriented whenever applicable, with constructors and destructors for each structure. 
\medskip

The include directory should be set to the \yroot directory, so that a yael file is included using the prefix \texttt{yael/}. 
For instance, including the primitive for vectors is performed by
\code{
\#include <yael/vector.h>
}
\medskip

The documentation of the functions and data structures is in the header files. It can be extracted and formatted by \texttt{doxygen}, run by invoking \texttt{make} in the \texttt{doc} subdirectory. 
\medskip

The best thing to do to have an operational Makefile and program 
is probably to look at the test files included in the 
\tc{\yroot/test/} subdirectory. 
\bigskip


\section{Conventions}

Vectors are represented as C arrays of basic elements. Functions
operating on them are prefixed with:

\begin{itemize}
\item
   \tc{ivec\_}: basic type is \tc{int}

\item
   \tc{fvec\_}: basic type is \tc{float}

\item
   \tc{dvec\_}: basic type is \tc{double}

\item 
   \tc{bvec\_}: basic type is \tc{unsigned char}

\end{itemize}

Vector sizes are passed explicitly, as long int's to allow for
large arrays on 64 bit machines. Vectors can be free'd with free().


Arrays of vectors are stored contiguously in memory. An array of n
float vectors of dimension d is 

\tc{float *fv}

The \tc{i}'th element of vector \tc{j} of vector array vf, where 0 $\le$ \tc{i} $<$ \tc{d} and 
0 $\le$ \tc{j} $<$ \tc{n} is

 
\tc{vf[ j * d + i ]}

It can also be seen as a column-major matrix of size \tc{d}, \tc{n}.

Since the library is intended to be fast, 32-bit floating point numbers are preferred over 64-bit ones almost everywhere. 

\section{Multi-threading in \yael}

In order to exploit multi-CPU and multi-core architectures, many functions in \yael execute in multiple threads. They take an additional parameter (\tc{int nt}) that defines the number of threads to use. 

The total number of available CPUs is given by the \tc{count\_cpu()} function. 

\subsection{Multi-threading primitive}

Most multi-threading operations in \yael are implemented via the function 
\begin{verbatim}
void compute_tasks (int n, int nt,
                    void (*task_fun) (void *arg, int tid, int i),
                    void *task_arg);
\end{verbatim}

The function executes \tc{n} tasks on \tc{nthread} threads. For each task, the callback \tc{task\_fun} is called with \tc{task\_arg} as first argument, \tc{i = 0..n-1} set to the task number, and \tc{tid = 0..nt-1} set to the thread number. 

Some operations are also multi-threaded via OpenMP pragmas. These are enabled only with the \tc{--enable-openmp} option to  \tc{./configure.sh}, else they will run single-threaded.


\subsection{Best practices}

It is often advisable to perform multi-threading at the highest level possible. For example, with two nested loops: 

\begin{verbatim}
for (i = 0 ; i < 1000 ; i++)    
  for (j = 0 ; j < 1000 ; i++) 
    expensive_operation (i, j);
\end{verbatim}

it is more efficient (and often easier) to define a task as one outer loop. This reduces the number of synchronization barriers. 


\subsection{Multithreading and random numbers}

\yael relies on the random number genrators \tc{rand()} and \tc{lrand48()}. These can be seeded, which changes a  global state variable. However, if the random number generators are called from multiple threads, the sequences get mixed and are not reproducible any more. 

To avoid this, several \yael functions that use random generators have an additional parameter that sets a local random seed. They are often suffixed with \tc{\_r} (\textbf{r}eentrant), for example: \tc{fvec\_new\_rand\_r}, \tc{ivec\_new\_random\_idx\_r}, \tc{kmeans}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Python}

The whole C API is exposed in Python using SWIG, hence the \tc{.swg} files in the subdirectories. This allows to call C functions from Python more or less transparently. 


\section{Loading and using \yael}

Assuming that the \tc{PYTHONPATH} environment variable is set to \yroot, 
importing the \yael interface and creating a new is done as 
\code{from yael import yael  \\
a = yael.fvec\_new\_0(5)
}

In order to shorten the call, one could also import the function 
in the current namespace, as
\code{from yael.yael import * \\
a = fvec\_new\_0(5)
}

However, we do not advise to do so, in order to avoid function name conflicts 
when using other python libraries jointly with \yael. 

\section{Guidelines for the wrapping process}

\begin{itemize}
\item for most of the objects, memory is not managed by Python. They must be free'd explicitly. The main exception is for vectors, which can be explicitly acquired by Python so that they are garbage-collected like a Python object;
\item arrays for simple types are wrapped with \tc{ivec}, \tc{fvec}, etc. 

  Usage:

      \tc{a = ivec(4)} constructs an array of 4 ints, accessible in Python with \tc{a[2]}, as one would expect. There is no bound checking: the Python object does not know about the size of the array (like in C).

      \tc{a.cast()} returns an int* usable as a C function argument (most of the time, the cast is automatic, and \tc{a} can be used when a function expects an \tc{int *})
      % if x is a int* in C, ***RV: c'est pas automatiquement fait, ca? ***
      
      if a C function returns an \tc{int*}, \tc{b=ivec.frompointer(x)} makes the Python \tc{a[i]} valid to access C's \tc{x[i]}.

      \tc{b.plus(2)} returns \tc{x+2} (pointer arithmetic).

      \tc{b=ivec.acquirepointer(x)} will in addition make \tc{free(x)} when \tc{b} is deleted. This function therefore ensures that \tc{x} will be collected 
by the python garbage manager. Often, when a C function returns a newly allocated pointer \tc{x}, it is advisable to do: \tc{x=ivec.acquirepointer(x)}

%\item Any function that may last long must be wrapped with the macro \tc{PARALLEL\_FUNCTION} in the SWIG code, or it will block other threads from executing. 

\item all wrapped functions release Python's Global Interpreter Lock, so Python API functions should not be called in C code.

\item output arguments in the C code (marked with \tc{\_out}) are combined with the function results tuples. 
\end{itemize}


\section{NumPy interface}

If Yael is configured with \tc{--enable-numpy}, arrays can be
exchanged with Numpy arrays. This is done through a series of functions with self-explanatory names: 

\begin{verbatim}
fvec_to_numpy 
ivec_to_numpy 
numpy_to_fvec 
numpy_to_ivec 
\end{verbatim}

Arrays corresponding to Yael's \tc{fvec} are of Numpy's \tc{dtype='float32'}.  

These functions copy their arguments. To share the same data buffer between Yael and Numpy, suffix the function with \tc{\_ref}. 

See the \tc{test\_numpy.py} program for an example usage. 

\chapter{Matlab}

This chapter is dedicated to the Matlab interface. 
However most of the comments here have their Octave equivalent. 

\section{Content of the matlab interface}

The matlab interface of \yael is quite limited because most 
of the functions are standard in matlab or can be straightforwardly 
implemented. 
The list of functions currently provided is the following
\begin{description}
\item  [yael\_kmeans.] Although there is a kmeans function in matlab, 
that one is not very efficient. Moreover, it is not available in 
the core matlab program, since it requires a specific toolbox. 
\item [yael\_knn] is used to find the $k$ nearest neighbors with respect 
to the Euclidean distance. Although for $k=1$ matlab makes a good job, 
finding $k>1$ neighbors requires to use the \tc{sort} 
function, which is very inefficient when $k$ is small compared to the number 
of vectors. 
\item [yael\_L2sqr] computes all the square distances between two sets of vectors. 
Therefore, it computes $n_1\times n_2$ distances. 
\item [yael\_kmin and yael\_kmax] compute the $k$ smallest (respectively largest) 
values of a set of scalar. It is more efficient than sorting the data. 
\item [yael\_fvecs\_normalize] normalizes a set of vectors. 
\item [yael\_gmm] learns a Gaussian mixture model (diagonal form).
\item [yael\_fisher] computes the Fisher Kernel representation of a set of features. 
\end{description}

There are also several I/O functions, see Chapter~\ref{cha:I/O}. 

\section{Using the \yael interface}

The functions are implemented by Mex-file, 
which requires to compile the matlab interface of \yael 
(not done by default). To do so, just type \tc{make}
in the \tc{\yroot/matlab} directory\footnote{You might 
obtain a warning about the version of mex. We never observed 
any trouble related to that point. }. 
In order for the matlab functions to be found in matlab, 
you should include this subdirectory in the MATLAB path, for 
instance by putting the command 

\code{
export MATLABPATH=\$MATLABPATH:\yroot/matlab
}

in your shell configuration files (e.g., \tc{.bash\_profile} for bash) 
where \yroot should be set to fit your local configuration 
(see Chapter~\ref{cha:gettingstarted}). 
\bigskip

Similar to Fortran convention, all vectors are assumed stored in column. 
\bigskip

All the functions of the \yael matlab interface use 
single precision vectors, i.e., the matlab 
equivalent of float. This is in contrast to matlab default type, 
where double precision floating numbers are used by default. 
Therefore, one has to cast the input data to single precision 
when calling \yael functions, e.g., as 

\code{
[dis,ids]=yael\_nn(single(v),single(q),10)
}

\chapter{Troubleshooting}

Before reporting any trouble in installing the library, please
ensure that the following points are correctly configured 
Most of the problems should be related to an incorrect configuration 
in~\tc{makefile.inc}. 


\begin{description}
\item [Problems when linking.] The environment variable associated with dynamic library should be set to \tc{\yroot/yael}. 

{~ \hfill 
\begin{tabular}{|lll|}
\hline
Architecture & \yael library name  &  environment variable  \\
\hline
Linux 32/64  & \tc{libyael.so}  & \tc{LD\_LIBRARY\_PATH} \\
MacOS       & \tc{libyael.dylib} & \tc{DYLD\_LIBRARY\_PATH} \\
\hline
\end{tabular} \hfill ~}

\item [Python.] The \tc{PYTHONPATH} environment variable should 
point to \tc{YAELROOT}. 


To check the dependencies for the library, you can use the following commands:
\begin{itemize}
\item Linux: \tc{ldd libyael}
\item MacOS: \tc{otool -L libyael.dylib}
\end{itemize}

\item [Segfault in Mexfile: MacOS 64 bits.] If you have a 64 bits Matlab version with MacOS, 
then you should check that you have used the flag --mac64 when configuring \yael. 
\end{description}


\appendix                     % Les annexes

\chapter{File exchange format}               % Annexe A
\label{cha:I/O}

\yael uses a home-made file format to store byte, integer or floating point vectors. 
Each vector is stored by
\begin{itemize}
\item writing its length $d$ as an integer
\item and writing its $d$ components in binary format. 
\end{itemize}
We only store single-precision floating point number\footnote{For
  double precision you need to use the standard I/O functions. But do
  you really need double precision ?}. Therefore the size of storing a
vector of integer or a vector of floating point numbers is always
\tc{sizeof(int)+4*d}$=4(d+1)$, as both the dimension and the
components require 4 bytes each. 
For byte vectors, it is similarly equal to $4+d$. 
 \medskip

By convention we will call a file containing several vectors of the same kind ``fvecfile'', ``ivecfile'' 
and 'bvecfile'. 
Some particular high-level functions are defined for these files. 
\bigskip

{\it Remarks:} 
\begin{itemize}
\item Since there use no header, several files of same type can be concatenated using regular the \tc{cat} Unix command to produce a file containing the concatenation of the vector. 
\item the front-ends \tc{xvecfile} (x='f','i' or 'b') receive a xvecfile on standard input and produce a text output. Usage:
\code{
cat myfile.fvecs | fvecfile
}
or, equivalently, 
\code{
fvecfile < myfile.fvecs
}
They are provided in the prog directory. 
\end{itemize}


One can see below the set of \yael functions used to read these files in C, Python 
and matlab:
\begin{center}
\begin{tabular}{lll}
\hline
file type & read        & write \\
\hline
.fvecs    & fvecs\_read & fvecs\_write \\
.ivecs    & ivecs\_read & ivecs\_write \\
.bvecs    & bvecs\_read & bvecs\_write \\
\hline
\end{tabular}
\end{center}

The prototype of the function depends on whether you call it from C, Python or Matlab. 


Recall that these functions should be used only for files containing vectors of same type and dimension. 
However, thanks to the fact that the dimension is stored for each vector, variable length vectors 
can also be used, but in that case vectors must be accessed one by one. 
See the I/O interface in vector.h 

% \listoffigures              % Table des figures

% \listoftables               % Liste des tableaux

\end{document}
